//在C++和C#中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区
如何设计一个C++的类：
哪怕是最基础不过的类，也需要涉及到以下的知识点。能够熟悉并且驾驭这些知识点，是能够写出一个C++类的前提。此外，这些知识点也如同一个checklist，在review代码的时候可以对照着逐项进行检查：

对象的初始化方式；
构造函数；
拷贝构造函数、赋值运算符；
移动构造函数、移动赋值运算符；
析构函数；
继承体系；
Rule of Three/Five；
访问控制；
传值和传引用；
const语义；
智能指针作为类的成员；
异常处理；
标准库使用；
模板设计模式；
线程安全及可重入；
上述内容中，“线程安全及可重入”、“模板设计模式”是非常大的话题

基础类型在新标准中的初始化
开始本文前，先提及下内置类型在C++11标准后新增的初始化方式。

基础类型如下所示：

bool
char系列：char、wchar_t、char16_t、char32_t；
int系列：short、int、long、long long；
float系列：float、double、long double；
孔乙己吃着茴香豆说,茴字有四样写法,你知道么? 在c++里，基础类型也有四种初始化写法，你知道吗？

int gemfield = 7030;
int gemfield(7030);
int gemfield = {7030};
int gemfield{7030};
其中后两者就是c++11新增的list initialization。基础类型如果没有像上面这样使用四种方式显式进行初始化的话，那么就会：

如果定义在函数外，那么会被默认初始化为0；
如果定义在函数内，则默认初始化为undefined值；
类的构造函数
构造函数决定了一个类的对象是如何被初始化的。

1，默认构造函数与合成默认构造函数

没有参数的构造函数叫做默认构造函数（default constructor），如果一个类没有定义任何构造函数，那么编译器会自动生成一个，称之为合成默认构造函数（synthesized default constructor）。一旦类中用户显式的定义了任何的构造函数，那么编译器将停止自动生成默认构造函数。那么编译器生成的构造函数是如何知道怎么初始化当前类的各个成员呢？原则很简单：

如果成员有in-class initializer，那么就用它初始化该成员;
反之，就default-initialize该成员。
有意思的事情来了。你来说说下面这个简单的代码中，类Gemfield初始化的时候，其成员a_分别会被初始化几次呢？

class A{
public:
    A(int i){}
};

//1st
class Gemfield{
public:
    Gemfield(){}
    A a_={3};
};

//2nd
class Gemfield{
public:
    Gemfield():a_(4){}
    A a_={3};
};

//3rd
class Gemfield{
public:
    Gemfield():a_(4){a_= 5;}
    A a_={3};
};
请原谅我这里使用了带参数的构造函数来举例，主要是为了区分不同的初始化，原理一样。

第一种情况，成员a_会使用3作为构造函数的参数初始化1次；
第二种情况，成员a_会使用4作为构造函数的参数初始化1次；
第三种情况，成员a_会使用4作为构造函数的参数初始化1次，然后在构造函数体内部使用参数5进行一个临时对象的构造（代码是等号右边的{5} ），然后会调用合成的assign operator将该临时对象赋值给a_，这是converting constructor的一个典型场景。
因为默认构造函数在很多场景下都会被用到（比如：定义一个局部对象却没有使用initializer的时候；作为别的类的成员而该类又有默认构造函数的时候，等等），因此，设计一个类的最佳实践之一就是：总是为该class设计一个默认构造函数。

2，用户定义的构造函数

前面已经提到过，一旦类中用户定义了任何的构造函数，那么编译器将会停止自动生成默认构造函数。那么如果这种情况下，我们依然想要编译器自动生成一个默认构造函数，那该怎么办呢？使用新标准中的：

Gemfield() = default;
用户定义构造函数是更常见的行为，因为编译器合成的默认构造函数在大多数情况下都不能满足我们的需要，比如：

类中需要自定义的资源初始化方式；
类中某些成员并没有默认构造函数；
在用户定义的构造函数中，最重要的一个事情就是构造函数初始化列表（constructor initializer list）。如果编译器不支持in-class initializer的话，就只能使用constructor initializer list了。总而言之，在进入用户定义的构造函数体之前，类的成员已经被初始化过一遍了，使用的正是如下的三种方式之一（三选一）：

default initialize；
in-class initializer；
constructor initializer list；
而一旦进入构造函数体之后，再想修改该类的成员，就只能使用assign operator了。那么什么情况下只能使用构造函数初始化列表（constructor initializer list）来对类的成员进行初始化呢？以下四种情况：

成员是const类型；
成员是引用类型；
成员的类型没有定义默认构造函数；
追求构造效率的；
3，代理构造函数（delegating constructor）

C++11还新增了delegating constructor，就是一个构造函数的构造函数初始化列表（constructor initializer list）部分可以换成其它参数列表的构造函数，然后再追加自身的函数体。

4，转换构造函数（Converting constructors）

当构造函数可以使用一个参数进行调用的时候，这个构造函数就是转换构造函数（Converting constructors）。构造函数可以使用一个参数进行调用意味着以下两种情况：

构造函数只有一个参数；
构造函数有多个参数，但除了第一个外都有默认值；
也就是说，转换构造函数（Converting constructors）定义了从构造函数的参数类型到当前class type的隐式转换。转换构造函数说的是一种类型通过构造函数转换为当前的class类型，那么这种行为的反义词――如何将当前class的类型转换为其它类型――是什么呢？Conversion operator ！

转换构造函数（Converting constructors）有什么用呢？两种场景。

当赋值操作的时候，比如前面遇到过的代码：
class A{
public:
    A(int i){}
};

class Gemfield{
public:
    Gemfield():a_(4){a_= 5;}
    A a_={3};
};
这里的a_ = 5能直接赋值，将int类型转化为了class A类型，就是因为class A的构造函数正是converting constructor。

当传参的时候，比如函数的形参类型是A，但是我们实参可以传递一个int类型。
注意，Converting constructors只允许同时进行一种类型的转换，比如形参类型是B，而B拥有一个Converting constructors，其参数类型为string，这个时候如果你传递字符串"this is gemfield test"是不行的，因为字符串到string是一次类型转换，而string到class B又是一个类型转换，同时有两次转换是不行的。解决方案就是你可以在这两处任选一处做个显式的强制类型转换。

标准库里有这样的用法吗？有。比如string类：

string gemfield = "this is gemfield test"；
如果我想禁用转换构造函数（Converting constructors），那该怎么办呢？使用explicit关键字。explicit用在声明的地方，不能用在定义的地方。值得注意的是，只有在转换构造函数（Converting constructors）上添加explicit关键字才有意义，如果构造函数有多个参数（也即不是converting constructor），那本来也没有隐式的类型转换，那填不填加explicit就没有意义了。

一旦使用explicit关键字禁用了转换构造函数（Converting constructors），那么构造函数只能接收一样的类型来直接初始化了，或者使用显式的强制类型转换先将参数的类型转成一致的。

5，继承构造函数（inherit constructor）

C++11后，我们可以在子类中使用using关键字来复用基类的构造函数:

class D : public B{
    public:
        using B::B;
};
称之为继承构造函数（inherit constructor）。通过使用using关键字，我们将基类class B中的所有的构造函数都以如下的形式在子类class D中重新定义了一遍：

D(params) : B(args) {};
这种继承构造函数有如下特点需要在实践中注意：

不管在哪写using，子类构造函数的access level和基类一样（public、private、protected）；
不能自行添加explicit和constexpr，但是如果基类有explicit或constexpr那么子类也有，基类没有子类也没有；
基类构造函数中有默认参数的话，子类会去掉默认参数，并且生成多个版本的构造函数；比如基类只有一个构造函数（带两个参数，第二个参数有默认值），那么子类就会生成两个构造函数，其中一个有两个参数，另外一个只有一个参数；
如果基类中有多个构造函数，子类也会生成同样数量的构造函数（先不考虑上述的默认参数情况）；但如果子类手动实现了其中一种，那只有其它的构造函数才会被继承过来；
自动合成的默认构造函数不会被继承，子类会由编译器使用同样的规则自动合成；
继承而来的构造函数并不会被当做用户自定义构造函数，因此，如果子类中只有这种继承而来的构造函数，那么编译器就会自动合成默认构造函数；
拷贝构造函数
如果构造函数的第一个参数是该类的引用类型，并且其它参数都有默认值，那么这个构造函数就是拷贝构造函数（copy constructor）。只要用户不自定义拷贝构造函数，编译器就会自动合成。合成拷贝构造函数的特点就是，它会执行对象之间的memberwise copy来进行对象的拷贝构造。拷贝构造函数在多个场景下都会用到：

拷贝初始化（Copy initialization），使用一个对象初始化另一个对象的时候，比如：
A a1 = a2;
注意，一定要和赋值运算符区分开来。等号左边是未初始化的对象时，这是拷贝构造；如果是已经初始化过（包括默认初始化），则是赋值运算符，比如下面这样就是赋值运算符：

A a1;

//a1已经默认初始化了
a1 = a2;
函数调用时候的传参（形参类型不是引用），也就是传值的时候会调用拷贝构造函数。这个很有趣，也解释了为什么拷贝构造函数的参数必须是引用类型。假设拷贝构造函数的参数类型不是引用而是传值，那么传值就要调用拷贝构造函数，这就变成了鸡生蛋和蛋生鸡的问题了。
接收返回值，且返回值类型不是引用的时候；
使用大括号初始化数组里的元素、aggregate class的成员的时候；
注意，在标准库的容器添加元素的时候，insert、push等是copy initialization，而emplace操作是直接初始化。

赋值运算符
这个和拷贝构造函数类似，值得说的地方有3处（以编译器自动合成的赋值运算符为例）：

为了和内置类型的行为一致，赋值运算符的返回值为等号左边操作符的引用；
参数不一定要为引用类型，因为没有鸡生蛋的问题；但最好是reference to const类型；
如果成员是数组类型，数组中的每个元素都会被赋值操作；
为什么叫赋值运算符而不是赋值构造函数呢？因为构造函数是没有返回值的，而赋值运算符是有返回值的。返回值的类型最好是non-const reference，并且指向等号左边的对象。为什么呢？假设返回的是void或者其它类型，那么对于 a = b = c这样的表达式怎么办呢？哈哈哈哈。

实践中一定要注意对参数进行检查，防止自己赋值给自己的情况发生。

移动构造函数和移动赋值运算符
移动语义是要作用在右值引用（Rvalue references）上的，你可以参考这篇文章：

Gemfield：C++的类型推导
46 赞同 ・ 1 评论文章

在这篇文章中，你可以得知――比如吧，变量是“左值”，那么右值引用类型定义的变量也是“左值”，因此右值引用变量类型定义的变量(gemfield)是无法绑定到另一个右值引用类型变量(gemfield2)上的：

int&& gemfield = 7030;

//错误
int&& gemfield2 = gemfield;

//正确，你可以使用std::move将gemfield转换为右值
int&& gemfield2 = std::move(gemfield);
好了，回到本文。移动构造函数在C++11中出现的意义――或者说为了解决的问题――是对象在资源的管理中如何拥有更高的效率。比如，在如下的情况下，move一个“资源”显然要比copy一个资源在效率上获得极大提升：

a=b，当把b拷贝给a时，并且b又不再需要的时候。这个时候move就要好于copy；把b的资源直接由a托管，比“a中申请空间+b拷贝给a+销毁b” 要快的多；
在如下的情况下，只有move一个“资源”才有意义：

unique_ptr1 = unique_ptr2；因为unique_ptr只能独享资源，这个时候用move再合适不过了；
IO对象，因为IO对象的buffer无法共享；
这些“资源”就和我们前面提到的右值引用要产生关系了。根据上面的例子，我们得到一个重要的事实就是：右值引用（Rvalue references）引用的是那些即将销毁的对象，这也是为什么我们从右值引用上“移走”想要的资源是合理的。

标准库中的容器、string、shared_ptr支持copy和move，标准库中的IO和unique_ptr只有move语义（就像上面说的那样）。

一个类必须具备移动构造函数才具备移动语义，其对象才支持move操作，就像上面的容器、string这样的类。那么如何为自己的类定义一个移动构造函数呢？我们可以换个视角，因为移动构造函数和拷贝构造函数最相似，我们就和拷贝构造函数来比较，看看这两者不一样的地方是什么：

移动构造函数的形参类型是右值引用类型，和拷贝构造函数的reference to const是不一样的:
Gemfield(Gemfield&&) = default;
移动构造函数的逻辑必须确保被move的对象处于一种无害状态，具体来说，被move的对象必须不再拥有其之前管理的资源，因为这些资源已经由新的对象接管了；被move的对象还需要能够被安全的析构；
移动构造函数不参与新的资源的申请，因此一般不会throw异常，于是最好是被noexcept修饰；此外，noexcept修饰的移动构造函数还具备其它的意义，标准库能否看到这个noexcept承诺会有不一样的行为。比如vector在push_back一个对象时，如果该对象的move constructor不能承诺noexcept，那么vector会转而使用这个对象的copy constructor，以确保vector在reallocation错误的时候，不会犯下回不去的错误。
那么移动构造函数会像拷贝构造函数那样被编译器自动合成吗（如果用户没有自定义的话）？回顾一下，对于默认构造函数、拷贝构造函数、赋值运算符、析构函数来说，当用户没有声明且程序中使用到了该类型的构造、拷贝、赋值、析构，那么编译器会自动合成相应的默认构造函数、拷贝构造函数、赋值构造、析构函数；但是对于移动构造函数来说，情况就完全不一样了。

编译器只有在以下情况下才会自动合成移动构造函数：

用户没有声明拷贝构造函数，且
用户没有声明赋值运算符（copy assignment operator），且
用户没有声明移动赋值运算符（move assignment operator），且
用户没有声明析构函数，且
所有非static成员都是可moveable的，且
父类们都是可moveable的。
编译器只有在以下情况下才会自动合成移动赋值运算符：

用户没有声明拷贝构造函数，且
用户没有声明赋值运算符（copy assignment operator），且
用户没有声明移动构造函数（move constructor），且
用户没有声明析构函数，且
所有非static成员都是可moveable的，且
父类们都是可moveable的。
和拷贝构造不同的是，编译器不会自动合成=delete的移动构造函数，但如果我们主动使用=default来申请编译器来合成移动构造函数，而当前的类又因为下列情况而不满足move条件，那么合成的移动构造函数就是=delete的：

成员的类型定义了copy但没定义move；
成员类型的move是=delete的或者不可访问（比如private）；
析构函数是=delete的或者不可访问；
如果类有const或者reference类型，则合成移动赋值运算符会被=delete；
当然，编译器不自动合成那就用户自定义呗。

析构函数
和构造函数一样，析构函数也没有返回值；和构造函数又不一样，析构函数没有参数，因此没有重载――也就是说一个类中只有一个析构函数。如果用户不定义析构函数，编译器会合成一个析构函数，该析构函数的函数体为空。

构造函数的函数体是在成员都初始化完毕之后再执行的，与之相反，析构函数则是在函数体执行完毕再开始销毁类的成员的。

在日常的实践中，如果你设计的类有虚函数，或者你的类有可能被继承，那么就将析构函数加上virtual关键字，成为虚析构函数。为什么呢？如果析构函数不是virtual的，很可能在代码中会出现base指针指向子类的对象，这个时候如果delete base指针就会导致未定义的行为。

The Rule of Three/Five
理解了类中资源的管理，你就会得出如下结论：

如果该类显式的定义了析构函数，则一般也需要显式的定义拷贝构造函数、赋值运算符（除非使用=delete直接禁止该类的拷贝和赋值）；
如果该类显式的定义了拷贝构造函数，则也需要显式的定义赋值运算符；反之亦然；
我们应该把拷贝构造、赋值运算符、移动构造、移动赋值运算符、析构函数看成一个整体，如果用户定义了其中一个，就应该定义所有的；
这就是C++11之前的Rule of Three，以及C++11之后的Rule of Five。

再来讨论下自动合成
阅读完前面的文章，你也许看到或者在其它地方听说过，有些情况下“移动构造函数不会被合成，有些情况下“移动构造函数会被合成为=delete”，那这两者有什么区别呢？

“=delete”参与函数重载，如果被匹配到了，那就不好意思啦――编译报错；
“不会被合成“表示没有被合成/根本不存在，那就不参与函数重载。
下面就列出一些场景，在这些场景下，编译器会自动合成相关的函数，并且被标记为=delete：

如果class中有一个成员的析构函数为=delete或者不可访问（比如private），那么该class的自动合成析构函数也会被标记为=delete；
如果class中有一个成员的拷贝构造函数为=delete或者不可访问（比如private），或者析构函数为=delete或者不可访问（比如private），那么该class的自动合成拷贝构造函数也会被标记为=delete；
如果class中有一个成员的赋值运算符为=delete或者不可访问（比如private），或者有成员的类型为const或者引用，那么该class的自动合成赋值运算符也会被标记为=delete；
如果class中有一个成员的类型为引用但是并没有in-class的initializer，或者有一个成员的类型为const但是没有默认构造函数和in-class initializer， 那么该class的自动合成默认构造函数也会被标记为=delete；
如果用户定义了移动构造函数或者移动赋值运算符，那么合成的拷贝构造函数和赋值运算符会被标记为=delete；
这里面其它规律还好说，但是=delete的析构函数会导致合成默认构造函数、拷贝构造函数也为=delete就让人猝不及防了。这是因为如果允许这种情况发生，那就会导致默认构造的对象无法析构。

如果感觉上面自动合成的场景有点复杂，那么在实践中就这么做，永远显示的定义这些函数。要么自定义，要们使用=default、=delete等向编译器主动申请（C++11之后）。

继承体系
OOP的思想在于封装、继承、多态。前面对于资源的封装我们已经感受的差不多了，现在来简单说说继承吧。

继承体系下，在构造函数、拷贝构造、赋值运算符、移动构造函数中，子类需要显式的初始化基类部分；而在析构函数中，子类只需要关心子类的部分。

继承体系下，类的构造函数/析构函数中调用该类的虚函数，则虚函数的版本不是常规的多态中的行为，而是使用当前构造函数/析构函数所属的类中的虚函数版本。

继承在实践中有一些关键的点：

不想让别人继承的话，自己的类加上final；
基类中的virtual函数，在子类中永远是virtual函数，不管在子类中加不加virtual关键字；
override关键字告诉用户：这是一个virtual函数, 而且是正在覆写基类中的虚函数；并且让编译器帮着做个检查，看是不是在覆写基类中的虚函数，而不是在创建一个新的函数（手抖什么的）；
对于编译器自动合成的那些函数来说：

如果基类的默认构造函数、拷贝构造函数、赋值运算符、析构函数被标记为=delete或者是不可访问的，那么子类中相应的成员也是=delete，这很好理解；
如果基类的析构函数是=delete或者是不可访问的，那么子类中自动合成的默认构造函数、拷贝构造函数也会被标记为=delete；
如果基类的析构函数是=delete或者是不可访问的，那么在子类中想用=default来请求编译器自动合成移动构造函数的话，移动构造函数也会被标记为=delete；
如果基类中的移动构造函数是deleted或者是不可访问的，那么子类中想用=default来请求编译器自动合成移动构造函数的话，移动构造函数也会被标记为=delete。
类的成员使用智能指针而不是裸指针
在普通函数里，我们都知道尽量要使用智能指针来管理动态内存。原因很简单，裸指针容易导致内存泄漏。让Gemfield来举个例子吧：

Gemfield* getGemfieldPtr(){
    Gemfield* p_gem = new Gemfield();
    return p_gem;
}
在这个例子中，当函数返回后，是调用者的责任来确保p_gem指向的内存被释放掉。万一：

调用者忘记了呢？
当前的调用者没有忘记，后来新的feature添加后，新的代码忘记了呢？
调用者没有忘记，但代码因为异常等原因，函数提前返回从而没走到delete逻辑呢？
调用者的逻辑里有多个指针变量指向同样的内存，导致多次delete呢？
种种原因，导致我们在实践中一定要使用智能指针。这块的内容，请参考：

Gemfield：C++的智能指针
50 赞同 ・ 5 评论文章
那么回到本篇文章，当写一个C++的类时，如果类成员是指针类型，那么是用裸指针好还是智能指针好呢？试想下，如果使用裸指针的话，一般情况下，我们在构造函数中为其分配内存，在析构函数中释放其内存，听起来不错。但是再考虑以下的问题呢：

类中没有定义析构函数，使用的是自动合成的析构函数......；
构造函数中，刚刚为该成员new了内存，之后构造函数抛异常了......；
该类的对象之间互相拷贝、赋值时，如果是合成拷贝构造函数，裸指针......；如果是用户定义的拷贝构造函数、赋值运算符，裸指针......；
该类的对象使用移动语义时，裸指针......；
考虑到种种情况，我们在类成员中也要尽量避免使用裸指针，转而使用智能指针。那么是使用shared_ptr还是unique_ptr呢？

如果class1和class2之间需要共享成员的话，指针成员使用shared_ptr；
如果class1和class2之间不共享成员的话，指针成员使用unique_ptr；
如果是单例模式的话，指针成员使用unique_ptr；
对于类的成员函数来说（好吧，也适用于非成员函数），使用智能指针的一些实践原则如下所示：

如果在函数中返回的资源想要由调用者管理的话，返回unique_ptr，调用者之后可以自己再自由发挥，比如可以把它赋给shared_ptr（如果想要的话）；
从函数中返回shared_ptr相对比较少，如果出现这种情况，那意思就是：函数的设计者想要延长该函数中创建的资源的生命周期；
从函数中很少返回weak_ptr，从调用者角度来看的话，如果调用者无从知晓返回的对象是否还在其生命周期中，则可以考虑使用weak_ptr；
如果从函数中返回的资源的生命周期并不由调用者介入或者管理，并且也管理不了，那么函数返回裸指针或者引用。
异常处理和stack unwinding
你设计的类的代码需要抛出异常吗？你需要catch自己代码（包括自己代码调用的三方库）的异常吗？只有清楚了解这些问题以及其后的背景，才能做到当异常被抛出的时候，程序依然能够行为正常，也就是常说的exception safe的代码。

比如，如果在类的构造函数中发生了异常呢？可能和很多人的直觉相反，在构造函数中因为错误而主动throw异常是标准行为。因为构造函数没有返回值，人们是无从得知其构造是否成功，如果有错误，就抛出异常。至于资源释放问题，请参考上述的智能指针环节。

class A{
    public:
        A(int i){i_ = i;}
        ~A(){}
    private:
        int i_;
};

class Gemfield{
    public:
        Gemfield(){a2 = new A(2); throw std::exception();}
        ~Gemfield(){}
    private:
        A a1{1};
        A* a2;
};
上面的代码片段中，类Gemfield的构造函数中抛出了异常，请回答以下问题：

Gemfield的析构函数会被调用吗？
a1的析构函数会被调用吗？也就是a1会被释放吗？
a2的析构函数会被调用吗？a2 new的资源会被释放吗？
如果在类的析构函数中发生了异常呢？应该在析构函数中抛出异常吗？这个小节的内容可以参考本专栏文章：C++的异常处理。

类设计中的其它小项
1，访问控制

就是public、protected、private这些关键字。注意，访问控制修饰符定义的是类的访问权限，而不是对象的访问权限。什么意思呢？比如Gemfield类有两个对象，g1和g2，g1是可以访问g2的private成员的。

不然拷贝构造、赋值运算符是怎么访问参数对象里的私有成员的呀，哈哈哈哈。

2，函数传参和返回值

传值还是传引用？一切为了效率出发。下面列举几个经典场景：

参数需要在函数内修改，并在函数外使用修改后的值：传引用；
参数需要在函数内修改，但在函数外使用修改前的值：传值；
参数不会被修改，参数类型为基础类型的话传值，为class类型的话传引用，并且是reference to const（参考：https://zhuanlan.zhihu.com/p/91075706）；
有些类型不允许copy（比如标准IO类型），则只能传引用；
一个函数绝对不要返回其内部局部变量的引用或者指针（不过，有一个常见的用法是类成员函数返回对this对象的引用）。另外，在C++11及之后，可以返回一个braced list了。

3，const成员函数

是否需要使用const关键字来修饰成员函数呢？const成员函数表明当前对象的“只读”性，一旦成员函数使用了const来修饰，就表明成员函数上隐式的this指针是reference to const的（注意：this本来就是const的），因此：

const对象上只能调用const成员函数；
非const对象上既可以调用非const成员函数，也可以调用const成员函数。
否则报错：error: 'this' argument to member function 'xxxx' has type 'const X', but function is not marked const。

4，使用C++标准库

C++标准库不用白不用，关键是，在任何一个支持C++的环境上，都默认有标准C++库（其它的库就没有这个地位了），所以我们应该优先使用标准库；标准库不满足的，优先使用header-only的库。C++标准库主要有：

顺序容器；vector、deque、list、forward_list、array、string；
关联容器；map、set、multimap、multiset、unordered_map、unordered_set、unordered_multimap、unordered_multiset；
通用算法；160多个通用算法、容器相关的算法。
关于C++标准库，请参考本专栏的其它文章：C++的标准库。


//指针
void f() { int* p=new int[5]; }

这条短短的一句话就包含了堆与栈，看到new，我们首先就应该想到，我们分配了一块堆内存，那么指针p呢？他分配的是一块栈内存，所以这句话的意思就是：在栈内存中存放了一个指向一块堆内存的指针p。在程序会先确定在堆中分配内存的大小，然后调用operator new分配内存，然后返回这块内存的首地址，放入栈中，他在VC6下的汇编代码如下：

00401028 push 14h                                       
0040102A call operator new (00401060) 
0040102F add esp,4                                      
00401032 mov dword ptr [ebp-8],eax   
00401035 mov eax,dword ptr [ebp-8]   
00401038 mov dword ptr [ebp-4],eax    

这里，我们为了简单并没有释放内存，那么该怎么去释放呢？是delete p么？澳，错了，应该是delete []p，这是为了告诉编译器：我删除的是一个数组，VC6就会根据相应的Cookie信息去进行释放内存的工作。